// Generated by CoffeeScript 1.12.7
(function() {
  var Client, _, apiClient, helper;

  _ = require('underscore');

  apiClient = require('./api_client');

  helper = require('./helper');

  Client = (function() {
    var setDelayBetweenRetries;

    function Client(options) {
      this.api = new apiClient.APIClient(options);
    }

    Client.prototype.codesList = function(options, cb) {
      return this.api.codesList(options, function(error, body) {
        if (error == null) {
          return cb(error, body.codes);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.codesGet = function(codeId, cb) {
      return this.api.codesGet(codeId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.codesDelete = function(codeId, cb) {
      return this.api.codesDelete(codeId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.codesRevisions = function(codeId, options, cb) {
      return this.api.codesRevisions(codeId, options, function(error, body) {
        if (error == null) {
          return cb(error, body.revisions);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.codesDownload = function(codeId, options, cb) {
      return this.api.codesDownload(codeId, options, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksList = function(options, cb) {
      return this.api.tasksList(options, function(error, body) {
        if (error == null) {
          return cb(error, body.tasks);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksGet = function(taskId, cb) {
      return this.api.tasksGet(taskId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksCreateBulk = function(tasks, cb) {
      return this.api.tasksCreate(tasks, function(error, body) {
        if (error == null) {
          return cb(error, body.tasks[0]);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksCreate = function(codeName, payload, options, cb) {
      return this.tasksCreateBulk([
        {
          codeName: codeName,
          payload: payload,
          options: options
        }
      ], cb);
    };

    Client.prototype.tasksRetry = function(taskId, delay, cb) {
      return this.api.tasksRetry(taskId, delay, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksCancel = function(taskId, cb) {
      return this.api.tasksCancel(taskId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksCancelAll = function(codeId, cb) {
      return this.api.tasksCancelAll(codeId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksLog = function(taskId, cb) {
      return this.api.tasksLog(taskId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksStdout = function(taskId, cb) {
      return this.api.tasksStdout(taskId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksSetProgress = function(taskId, options, cb) {
      return this.api.tasksSetProgress(taskId, options, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksWaitFor = function(taskId, options, cb) {
      var tasksWaitForBind;
      tasksWaitForBind = _.bind(this.tasksWaitFor, this);
      if (options.sleep == null) {
        options.sleep = 0.25;
      }
      if (options.timeout == null) {
        options.timeout = 3600;
      }
      if (options.tries == null) {
        options.tries = Math.round(options.timeout / 60) + 20;
      }
      options.tries--;
      if (options.tries < 0) {
        return cb(new Error('Timeout waiting for task execution'), null);
      }
      return this.tasksGet(taskId, function(error, body) {
        if (error == null) {
          setDelayBetweenRetries(options);
          if (body.status === 'queued' || body.status === 'preparing' || body.status === 'running') {
            return _.delay(tasksWaitForBind, options.sleep * 1000, taskId, options, cb);
          } else {
            return cb(error, body);
          }
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksWaitForLog = function(taskId, options, cb) {
      var tasksWaitForLogBind;
      tasksWaitForLogBind = _.bind(this.tasksWaitForLog, this);
      if (options.sleep == null) {
        options.sleep = 0.25;
      }
      if (options.tries == null) {
        options.tries = 10;
      }
      options.tries--;
      if (options.tries < 0) {
        return cb(new Error('Timeout waiting for task log'), null);
      }
      return this.tasksLog(taskId, function(error, body) {
        if (error && error.message.match(/log/i)) {
          setDelayBetweenRetries(options);
          return _.delay(tasksWaitForLogBind, options.sleep * 1000, taskId, options, cb);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksWaitForSyncTaskStdout = function(taskId, options, cb) {
      var tasksWaitForSyncTaskStdoutBind;
      tasksWaitForSyncTaskStdoutBind = _.bind(this.tasksWaitForSyncTaskStdout, this);
      if (options.sleep == null) {
        options.sleep = 0.25;
      }
      if (options.tries == null) {
        options.tries = 10;
      }
      options.tries--;
      if (options.tries < 0) {
        return cb(new Error('Timeout waiting for task stdout'), null);
      }
      return this.tasksStdout(taskId, function(error, body) {
        if (error && error.message.match(/log/i)) {
          setDelayBetweenRetries(options);
          return _.delay(tasksWaitForSyncTaskStdoutBind, options.sleep * 1000, taskId, options, cb);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.tasksRun = function(codeName, params, options, cb) {
      var tasksWaitForBind, tasksWaitForSyncTaskStdoutBind;
      options.sync = true;
      tasksWaitForBind = _.bind(this.tasksWaitFor, this);
      tasksWaitForSyncTaskStdoutBind = _.bind(this.tasksWaitForSyncTaskStdout, this);
      return this.tasksCreate(codeName, params, options, function(error, body) {
        var task_id;
        if (error) {
          return cb(error, body);
        } else {
          task_id = body.id;
          return tasksWaitForBind(task_id, {}, function(error, body) {
            if (error) {
              return cb(error, body);
            } else {
              return tasksWaitForSyncTaskStdoutBind(task_id, {}, function(error, body) {
                if (error) {
                  return cb(error, body);
                } else {
                  return cb(error, body);
                }
              });
            }
          });
        }
      });
    };

    Client.prototype.schedulesList = function(options, cb) {
      return this.api.schedulesList(options, function(error, body) {
        if (error == null) {
          return cb(error, body.schedules);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.schedulesGet = function(scheduleId, cb) {
      return this.api.schedulesGet(scheduleId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.schedulesCreate = function(codeName, params, options, cb) {
      var payload;
      payload = '';
      if (typeof params === 'string') {
        payload = params;
      } else {
        payload = JSON.stringify(params);
      }
      return this.api.schedulesCreate(codeName, payload, options, function(error, body) {
        if (error == null) {
          return cb(error, body.schedules[0]);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.schedulesCancel = function(scheduleId, cb) {
      return this.api.schedulesCancel(scheduleId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.codesUpload = function(name, destination, fileName, cb) {
      var AdmZip, api, fs, ncp, needle, zip;
      needle = require("needle");
      ncp = require("ncp").ncp;
      fs = require("fs");
      AdmZip = require("adm-zip");
      zip = new AdmZip();
      if (destination.charAt(destination.length - 1) !== "/") {
        destination += "/";
      }
      api = this.api;
      ncp.limit = 16;
      return ncp("upload_files", destination, function(err) {
        if (err) {
          throw err;
        }
        return fs.appendFile(destination + "__runner__.sh", "\nnode " + fileName, function(err) {
          var params;
          if (err) {
            throw err;
          }
          zip.addLocalFolder(destination);
          params = {
            data: JSON.stringify({
              name: name,
              file_name: "__runner__.sh",
              runtime: "sh",
              content_type: "text/plain"
            }),
            file: {
              buffer: zip.toBuffer(),
              content_type: "application/zip"
            }
          };
          return api.codesUpload(params, function(err, body) {
            if (err == null) {
              return cb(err, body);
            } else {
              return cb(err, body);
            }
          });
        });
      });
    };

    Client.prototype.clustersList = function(options, cb) {
      return this.api.clustersList(options, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.clustersGet = function(clusterId, cb) {
      return this.api.clustersGet(clusterId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.clustersStats = function(clusterId, cb) {
      return this.api.clustersStats(clusterId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.clustersCreate = function(clusterName, memory, disk, options, cb) {
      return this.api.clustersCreate(clusterName, memory, disk, options, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.clustersUpdate = function(clusterId, options, cb) {
      return this.api.clustersUpdate(clusterId, options, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.clustersDelete = function(clusterId, cb) {
      return this.api.clustersDelete(clusterId, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    Client.prototype.instanceTerminate = function(clusterId, instance_id, cb) {
      return this.api.instanceTerminate(clusterId, instance_id, function(error, body) {
        if (error == null) {
          return cb(error, body);
        } else {
          return cb(error, body);
        }
      });
    };

    setDelayBetweenRetries = function(options) {
      if (options.sleep < 60) {
        return options.sleep *= 2;
      }
    };

    return Client;

  })();

  module.exports.Client = Client;

  module.exports.params = helper.params;

  module.exports.config = helper.config;

  module.exports.taskId = helper.taskId;

  module.exports.taskDir = helper.taskDir;

}).call(this);
